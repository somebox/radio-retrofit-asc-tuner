external_components:
  - source:
      type: local
      path: ../components

esphome:
  name: retro-radio
  friendly_name: Retro Radio
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(controller).set_preset_target_sensor(id(current_media_id));
          id(controller).set_radio_mode_sensor(id(radio_mode));
          id(radio_mode).publish_state("presets");

# Global variables for clock mode
globals:
  - id: stopped_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: clock_mode_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: normal_brightness
    type: uint8_t
    restore_value: no
    initial_value: '180'

# Intervals for animations and clock
interval:
  # Spinner animation for loading state
  - interval: 500ms
    then:
      - lambda: |-
          static int spinner_pos = 0;
          static const char spinner_chars[] = "/-\\|";
          
          // Only show spinner if loading AND not browsing playlists
          bool is_browsing = (id(radio_mode).state == "playlists" && 
                             !id(controller).is_playlist_playing());
          
          if (id(stream_state).state == "loading" && !is_browsing) {
            // Show station name + spinner while connecting
            std::string station = id(station_name).state;
            if (station.empty()) {
              station = "Connecting";
            }
            
            // Build display with spinner always in last column (position 17, 0-indexed)
            // Truncate or pad station name to 17 chars, then add spinner
            if (station.length() > 17) {
              station = station.substr(0, 17);
            }
            std::string display_text = station + std::string(17 - station.length(), ' ') + spinner_chars[spinner_pos];
            id(display).set_text(display_text.c_str());
            spinner_pos = (spinner_pos + 1) % 4;
          }
  
  # Clock mode checker and updater
  - interval: 1s
    then:
      - lambda: |-
          // Enter clock mode when stopped and not in playlist mode
          // Check multiple conditions since stream_state may not always be updated
          bool in_playlist_mode = (id(radio_mode).state == "playlists");
          bool stream_stopped = (id(stream_state).state == "stopped" || 
                                 id(stream_state).state == "ready");
          bool no_media = id(current_media_id).state.empty();
          bool truly_stopped = (stream_stopped || no_media) && !in_playlist_mode;
          
          if (truly_stopped) {
            // Initialize stopped_time if this is the first check
            if (id(stopped_time) == 0) {
              id(stopped_time) = millis();
              ESP_LOGD("clock", "Started stopped timer (stream:%s, media:%s)", 
                       id(stream_state).state.c_str(), 
                       id(current_media_id).state.c_str());
            }
            
            // Enter clock mode after 10 seconds of being stopped
            unsigned long stopped_duration = (millis() - id(stopped_time)) / 1000;
            if (stopped_duration >= 10 && !id(clock_mode_active)) {
              ESP_LOGI("clock", "Entering clock mode after %lu seconds", stopped_duration);
              id(clock_mode_active) = true;
              
              // Use moderate brightness for clock (brighter than before)
              id(display).set_brightness(100);
            }
            
            // Update clock display if in clock mode
            // Format: "Oct  5 Su 19:15:46" (date at lower brightness, time at higher)
            if (id(clock_mode_active)) {
              auto time = id(ha_time).now();
              if (time.is_valid()) {
                char time_str[20];
                const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
                const char* days[] = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"};
                
                // Format: "Oct  5 Su 19:15:46" (18 chars)
                // First 10 chars are date (dimmer), last 8 are time (brighter)
                snprintf(time_str, sizeof(time_str), "%s %2d %s %02d:%02d:%02d",
                         months[time.month - 1],
                         time.day_of_month,
                         days[time.day_of_week - 1],
                         time.hour,
                         time.minute,
                         time.second);
                
                // Render with date dimmer (60) and time brighter (180)
                id(display).set_text_with_brightness(time_str, 60, 180, 10);
              }
            }
          } else {
            // Exit clock mode if streaming, loading, or media is active
            if (id(clock_mode_active)) {
              ESP_LOGI("clock", "Exiting clock mode");
              id(clock_mode_active) = false;
              
              // Restore normal brightness
              id(display).set_brightness(id(normal_brightness));
            }
            // Reset stopped timer
            id(stopped_time) = 0;
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

api:
  services:
    # Custom service to load playlist data (bypasses 255 char text limit)
    - service: load_playlists
      variables:
        playlist_json: string
      then:
        - lambda: |-
            ESP_LOGI("playlist", "Received playlist data via service");
            id(controller).load_playlist_data(playlist_json);

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Retro Radio Fallback"
  
  # Show connection status on display briefly, then let normal operation take over
  on_connect:
    - lambda: 'id(display).set_text("CONNECTED");'
    - delay: 2s
    - lambda: |-
        // Clear to "Ready" if nothing is playing
        if (id(now_playing).state.empty() || id(now_playing).state == "unknown") {
          id(display).set_text("Ready");
        } else {
          id(display).set_text(id(now_playing).state.c_str());
        }
  
  on_disconnect:
    - lambda: 'id(display).set_text("WIFI DISCONNECTED");'

# I2C bus configuration
i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: true
    frequency: 400kHz

# Time component (synced from Home Assistant)
time:
  - platform: homeassistant
    id: ha_time

# RetroText Display - 3 boards for 72x6 pixel display (18 characters)
retrotext_display:
  id: display
  brightness: 180  # Normal brightness (clock mode uses 60)
  boards:
    - 0x50  # Board 0 (left): ADDR=GND
    - 0x5F  # Board 1 (middle): ADDR=VCC  
    - 0x5A  # Board 2 (right): ADDR=SDA

# TCA8418 Keypad - Hardware matrix configuration
# AS5000E has 4 rows x 10 columns
tca8418_keypad:
  id: keypad
  address: 0x34
  rows: 4
  columns: 10

# Radio Controller - High-level preset management
# Note: Service calls disabled, using automation with text sensor instead
radio_controller:
  id: controller
  keypad_id: keypad
  display_id: display
  i2c_id: bus_a  # Auto-initialize panel LEDs at 0x55
  service: ""  # Disabled - using automation instead
  
  presets:
    - button: {row: 3, column: 3}
      display: "Radio 3FACH Luz"
      target: "Radio 3FACH"
    
    - button: {row: 3, column: 2}
      display: "WKCR Columbia U"
      target: "WKCR"
    
    - button: {row: 3, column: 1}
      display: "France Musique Hi-fi"
      target: "France Musique Hi-fi"
    
    - button: {row: 3, column: 0}
      display: "Radio Meuh FR"
      target: "Radio Meuh"
    
    - button: {row: 3, column: 8}
      display: "BBC NEWS"
      target: "radiobrowser://radio/98adecf7-2683-4408-9be7-02d3f9098eb8"
    
    - button: {row: 3, column: 7}
      display: "Radio LoRa"
      target: "Radio LoRa"
    
    - button: {row: 3, column: 6}
      display: "WTUL Tulane"
      target: "WTUL New Orleans"
    
    - button: {row: 3, column: 5}
      display: "BROWSE PLAYLISTS"
      target: "__PLAYLIST_MODE__"
  
  controls:
    encoder_button: {row: 2, column: 1}

# Text sensors
text_sensor:
  # Current preset name (display text)
  - platform: radio_controller
    radio_controller_id: controller
    name: "Current Preset"
    id: current_preset
    icon: mdi:radio
    on_value:
      then:
        # Store station name for use during loading
        - lambda: 'id(station_name).publish_state(x);'
  
  # Current preset target (media_id for automation)
  - platform: template
    name: "Current Media ID"
    id: current_media_id
    icon: mdi:music-circle
  
  # Radio mode: "presets" or "playlists"
  - platform: template
    name: "Radio Mode"
    id: radio_mode
    icon: mdi:radio
  
  # Now playing from Home Assistant
  - platform: homeassistant
    id: now_playing
    entity_id: sensor.radio_now_playing
    on_value:
      then:
        # Sync preset LED when HA reports the current stream
        - lambda: |-
            ESP_LOGI("now_playing", "Received: %s", x.c_str());
            
            // Exit clock mode if we have valid media
            if (!id(current_media_id).state.empty()) {
              if (id(clock_mode_active)) {
                ESP_LOGI("clock", "Exiting clock mode due to active media");
                id(clock_mode_active) = false;
                id(display).set_brightness(id(normal_brightness));
              }
              
              // Sync LED using the stored media_id (always use this, not now_playing text)
              ESP_LOGI("now_playing", "Syncing LED with media_id: %s", id(current_media_id).state.c_str());
              id(controller).sync_preset_led_from_target(id(current_media_id).state);
            }
        # Delay to allow preset name to show first
        - delay: 1.5s
        # Only update display when not loading or browsing playlists
        - lambda: |-
            // Don't overwrite display if browsing playlists
            bool is_browsing = (id(radio_mode).state == "playlists" && 
                               !id(controller).is_playlist_playing());
            
            if (id(stream_state).state != "loading" && !is_browsing) {
              id(display).set_text(x.c_str());
            }

# Select for preset selection
select:
  - platform: radio_controller
    radio_controller_id: controller
    name: "Radio Preset"
    icon: mdi:radio

# Text input for stream state (set by automation)
text:
  - platform: template
    name: "Stream State"
    id: stream_state
    optimistic: true
    initial_value: "ready"  # Changed from "stopped" to prevent clock flash on boot
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("stream_state", "Stream state changed to: %s", x.c_str());
            
            // Don't show "STOPPED" if in playlist mode at all
            // (either browsing or just started playing)
            bool in_playlist_mode = (id(radio_mode).state == "playlists");
            
            if (x == "stopped" && !in_playlist_mode) {
              id(display).set_text("STOPPED");
              // Reset stopped timer to start counting for clock mode
              id(stopped_time) = 0;
              
              // Clear media_id when stopped so clock mode can activate
              id(current_media_id).publish_state("");
            }
            // "loading" state will show station name + spinner in interval
            // "playing" state will be overridden by now_playing sensor
  
  - platform: template
    name: "Station Name"
    id: station_name
    optimistic: true
    initial_value: ""
    mode: text
    internal: true  # Hidden from HA UI
  
  # Station Name (internal, used for loading spinner)
  # Note: Playlist data is loaded via custom service below

# Number sensors
number:
  # Display brightness control
  - platform: template
    name: "Display Brightness"
    id: display_brightness
    optimistic: true
    min_value: 10
    max_value: 255
    step: 5
    initial_value: 180
    mode: slider
    icon: mdi:brightness-6
    on_value:
      then:
        - lambda: |-
            // Update display brightness
            id(display).set_brightness((uint8_t)x);
            // Store as normal brightness (for restoring after clock mode)
            id(normal_brightness) = (uint8_t)x;
            ESP_LOGI("brightness", "Display brightness set to: %d", (int)x);
  
  # Current browse index (for debugging)
  - platform: template
    name: "Browse Index"
    id: browse_index
    optimistic: true
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    mode: box
    internal: true  # Hidden from HA UI

# Optional: Expose preset buttons as binary sensors in Home Assistant
binary_sensor:
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 1"
    row: 3
    column: 3
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 2"
    row: 3
    column: 2
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 3"
    row: 3
    column: 1
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 4"
    row: 3
    column: 0
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 5"
    row: 3
    column: 8
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 6"
    row: 3
    column: 7
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 7"
    row: 3
    column: 6
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 8"
    row: 3
    column: 5
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Encoder Button"
    row: 2
    column: 1
