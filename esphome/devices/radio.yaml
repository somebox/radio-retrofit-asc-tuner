external_components:
  - source:
      type: local
      path: ../components

esphome:
  name: retro-radio
  friendly_name: Retro Radio
  on_boot:
    priority: -100
    then:
      - lambda: 'id(controller).set_preset_target_sensor(id(current_media_id));'

# Global variables for clock mode
globals:
  - id: stopped_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: clock_mode_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: normal_brightness
    type: uint8_t
    restore_value: no
    initial_value: '180'

# Intervals for animations and clock
interval:
  # Spinner animation for loading state
  - interval: 500ms
    then:
      - lambda: |-
          static int spinner_pos = 0;
          static const char spinner_chars[] = "/-\\|";
          
          if (id(stream_state).state == "loading") {
            // Show station name + spinner while connecting
            std::string station = id(station_name).state;
            if (station.empty()) {
              station = "Connecting";
            }
            
            // Add spinner character at the end
            std::string display_text = station + " " + spinner_chars[spinner_pos];
            id(display).set_text(display_text.c_str());
            spinner_pos = (spinner_pos + 1) % 4;
          }
  
  # Clock mode checker and updater
  - interval: 1s
    then:
      - lambda: |-
          // Only enter clock mode if we're truly stopped (no active media)
          bool truly_stopped = (id(stream_state).state == "stopped" && 
                                id(current_media_id).state.empty());
          
          if (truly_stopped) {
            // Initialize stopped_time if this is the first check
            if (id(stopped_time) == 0) {
              id(stopped_time) = millis();
            }
            
            // Enter clock mode after 10 seconds of being stopped
            unsigned long stopped_duration = (millis() - id(stopped_time)) / 1000;
            if (stopped_duration >= 10 && !id(clock_mode_active)) {
              ESP_LOGI("clock", "Entering clock mode after %lu seconds", stopped_duration);
              id(clock_mode_active) = true;
              
              // Dim display brightness
              id(display).set_brightness(60);
            }
            
            // Update clock display if in clock mode (with date format like ClockDisplay.cpp)
            if (id(clock_mode_active)) {
              auto time = id(ha_time).now();
              if (time.is_valid()) {
                // Format as "Aug 12 Th 12:43:25" (18 characters)
                char time_str[20];
                const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
                const char* days[] = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"};
                
                snprintf(time_str, sizeof(time_str), "%s %2d %s %02d:%02d:%02d",
                         months[time.month - 1],
                         time.day_of_month,
                         days[time.day_of_week - 1],
                         time.hour,
                         time.minute,
                         time.second);
                id(display).set_text(time_str);
              }
            }
          } else {
            // Exit clock mode if streaming, loading, or media is active
            if (id(clock_mode_active)) {
              ESP_LOGI("clock", "Exiting clock mode");
              id(clock_mode_active) = false;
              
              // Restore normal brightness
              id(display).set_brightness(id(normal_brightness));
            }
            // Reset stopped timer
            id(stopped_time) = 0;
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Retro Radio Fallback"
  
  # Show connection status on display briefly, then let normal operation take over
  on_connect:
    - lambda: 'id(display).set_text("CONNECTED");'
    - delay: 2s
    - lambda: |-
        // Clear to "Ready" if nothing is playing
        if (id(now_playing).state.empty() || id(now_playing).state == "unknown") {
          id(display).set_text("Ready");
        } else {
          id(display).set_text(id(now_playing).state.c_str());
        }
  
  on_disconnect:
    - lambda: 'id(display).set_text("WIFI DISCONNECTED");'

# I2C bus configuration
i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: true
    frequency: 400kHz

# Time component (synced from Home Assistant)
time:
  - platform: homeassistant
    id: ha_time

# RetroText Display - 3 boards for 72x6 pixel display (18 characters)
retrotext_display:
  id: display
  brightness: 180  # Normal brightness (clock mode uses 60)
  boards:
    - 0x50  # Board 0 (left): ADDR=GND
    - 0x5F  # Board 1 (middle): ADDR=VCC  
    - 0x5A  # Board 2 (right): ADDR=SDA

# TCA8418 Keypad - Hardware matrix configuration
# AS5000E has 4 rows x 10 columns
tca8418_keypad:
  id: keypad
  address: 0x34
  rows: 4
  columns: 10

# Radio Controller - High-level preset management
# Note: Service calls disabled, using automation with text sensor instead
radio_controller:
  id: controller
  keypad_id: keypad
  display_id: display
  i2c_id: bus_a  # Auto-initialize panel LEDs at 0x55
  service: ""  # Disabled - using automation instead
  
  presets:
    - button: {row: 3, column: 3}
      display: "Radio 3FACH Luz"
      target: "Radio 3FACH"
    
    - button: {row: 3, column: 2}
      display: "WKCR Columbia U"
      target: "WKCR"
    
    - button: {row: 3, column: 1}
      display: "France Musique Hi-fi"
      target: "France Musique Hi-fi"
    
    - button: {row: 3, column: 0}
      display: "Radio Meuh FR"
      target: "Radio Meuh"
    
    - button: {row: 3, column: 8}
      display: "BBC NEWS"
      target: "radiobrowser://radio/98adecf7-2683-4408-9be7-02d3f9098eb8"
    
    - button: {row: 3, column: 7}
      display: "Radio LoRa"
      target: "Radio LoRa"
    
    - button: {row: 3, column: 6}
      display: "WTUL Tulane"
      target: "WTUL New Orleans"
  
  controls:
    encoder_button: {row: 2, column: 1}

# Text sensors
text_sensor:
  # Current preset name (display text)
  - platform: radio_controller
    radio_controller_id: controller
    name: "Current Preset"
    id: current_preset
    icon: mdi:radio
    on_value:
      then:
        # Store station name for use during loading
        - lambda: 'id(station_name).publish_state(x);'
  
  # Current preset target (media_id for automation)
  - platform: template
    name: "Current Media ID"
    id: current_media_id
    icon: mdi:music-circle
  
  # Now playing from Home Assistant
  - platform: homeassistant
    id: now_playing
    entity_id: sensor.radio_now_playing
    on_value:
      then:
        # Sync preset LED when HA reports the current stream
        - lambda: |-
            ESP_LOGI("now_playing", "Received: %s", x.c_str());
            
            // Exit clock mode if we have valid media
            if (!id(current_media_id).state.empty()) {
              if (id(clock_mode_active)) {
                ESP_LOGI("clock", "Exiting clock mode due to active media");
                id(clock_mode_active) = false;
                id(display).set_brightness(id(normal_brightness));
              }
              
              // Sync LED using the stored media_id (always use this, not now_playing text)
              ESP_LOGI("now_playing", "Syncing LED with media_id: %s", id(current_media_id).state.c_str());
              id(controller).sync_preset_led_from_target(id(current_media_id).state);
            }
        # Delay to allow preset name to show first
        - delay: 1.5s
        # Only update display when not loading (loading shows spinner)
        - lambda: |-
            if (id(stream_state).state != "loading") {
              id(display).set_text(x.c_str());
            }

# Select for preset selection
select:
  - platform: radio_controller
    radio_controller_id: controller
    name: "Radio Preset"
    icon: mdi:radio

# Text input for stream state (set by automation)
text:
  - platform: template
    name: "Stream State"
    id: stream_state
    optimistic: true
    initial_value: "ready"  # Changed from "stopped" to prevent clock flash on boot
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("stream_state", "Stream state changed to: %s", x.c_str());
            if (x == "stopped") {
              id(display).set_text("STOPPED");
              // Reset stopped timer to start counting for clock mode
              id(stopped_time) = 0;
            }
            // "loading" state will show station name + spinner in interval
            // "playing" state will be overridden by now_playing sensor
  
  - platform: template
    name: "Station Name"
    id: station_name
    optimistic: true
    initial_value: ""
    mode: text
    internal: true  # Hidden from HA UI

# Optional: Expose preset buttons as binary sensors in Home Assistant
binary_sensor:
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 1"
    row: 3
    column: 3
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 2"
    row: 3
    column: 2
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 3"
    row: 3
    column: 1
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 4"
    row: 3
    column: 0
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 5"
    row: 3
    column: 8
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 6"
    row: 3
    column: 7
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 7"
    row: 3
    column: 6
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Preset Button 8"
    row: 3
    column: 5
  
  - platform: tca8418_keypad
    tca8418_keypad_id: keypad
    name: "Encoder Button"
    row: 2
    column: 1
