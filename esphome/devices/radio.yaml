external_components:
  - source:
      type: local
      path: ../components

esphome:
  name: retro-radio
  friendly_name: Retro Radio
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(controller).set_preset_target_sensor(id(current_media_id));
          id(controller).set_radio_mode_sensor(id(radio_mode));
          id(radio_mode).publish_state("presets");

# Global variables for clock mode and state
globals:
  - id: stopped_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: clock_mode_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: normal_brightness
    type: uint8_t
    restore_value: no
    initial_value: '180'
  - id: last_preset_name
    type: std::string
    restore_value: yes
    initial_value: '""'

# Intervals for animations and clock
interval:
  # Spinner animation for loading state
  - interval: 500ms
    then:
      - lambda: |-
          static int spinner_pos = 0;
          static const char spinner_chars[] = "/-\\|";
          
          // Only show spinner if loading
          if (id(stream_state).state == "loading") {
            // Show station name + spinner while connecting
            std::string station = id(station_name).state;
            if (station.empty()) {
              station = "Connecting";
            }
            
            // Add play icon (glyph 128) at the start
            std::string display_text;
            display_text += (char)128;  // Play icon
            display_text += ' ';  // Space after icon
            
            // Truncate station name to fit (18 chars total - 2 for icon/space - 1 for spinner = 15 chars max)
            if (station.length() > 15) {
              station = station.substr(0, 15);
            }
            display_text += station;
            
            // Pad and add spinner at the end
            display_text += std::string(15 - station.length(), ' ');
            display_text += spinner_chars[spinner_pos];
            
            id(display).set_text(display_text.c_str());
            spinner_pos = (spinner_pos + 1) % 4;
          }
  
  # Clock mode checker and updater
  - interval: 1s
    then:
      - lambda: |-
          // Enter clock mode when stopped and not in playlist mode
          // Check multiple conditions since stream_state may not always be updated
          bool in_playlist_mode = (id(radio_mode).state == "playlists");
          bool stream_stopped = (id(stream_state).state == "stopped" || 
                                 id(stream_state).state == "ready");
          bool no_media = id(current_media_id).state.empty();
          bool truly_stopped = (stream_stopped || no_media) && !in_playlist_mode;
          bool user_browsing = id(controller).is_browse_mode_active();
          
          // Reset clock timer if user is browsing
          if (user_browsing && id(clock_mode_active)) {
            ESP_LOGI("clock", "Exiting clock mode due to user browsing");
            id(clock_mode_active) = false;
            id(display).set_brightness(id(normal_brightness));
            id(stopped_time) = 0;  // Reset timer
          }
          
          if (truly_stopped && !user_browsing) {
            // Initialize stopped_time if this is the first check
            if (id(stopped_time) == 0) {
              id(stopped_time) = millis();
              ESP_LOGD("clock", "Started stopped timer (stream:%s, media:%s)", 
                       id(stream_state).state.c_str(), 
                       id(current_media_id).state.c_str());
            }
            
            // Enter clock mode after 10 seconds of being stopped
            unsigned long stopped_duration = (millis() - id(stopped_time)) / 1000;
            if (stopped_duration >= 10 && !id(clock_mode_active)) {
              ESP_LOGI("clock", "Entering clock mode after %lu seconds", stopped_duration);
              id(clock_mode_active) = true;
              
              // Use moderate brightness for clock (brighter than before)
              id(display).set_brightness(100);
            }
            
            // Update clock display if in clock mode
            // Format: "Oct  5 Su 19:15:46" (date at lower brightness, time at higher)
            if (id(clock_mode_active)) {
              auto time = id(ha_time).now();
              if (time.is_valid()) {
                char time_str[20];
                const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
                const char* days[] = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"};
                
                // Format: "Oct  5 Su 19:15:46" (18 chars)
                // First 10 chars are date (dimmer), last 8 are time (brighter)
                snprintf(time_str, sizeof(time_str), "%s %2d %s %02d:%02d:%02d",
                         months[time.month - 1],
                         time.day_of_month,
                         days[time.day_of_week - 1],
                         time.hour,
                         time.minute,
                         time.second);
                
                // Render with date dimmer (60) and time brighter (180)
                id(display).set_text_with_brightness(time_str, 60, 180, 10);
              }
            }
          } else {
            // Exit clock mode if streaming, loading, or media is active
            if (id(clock_mode_active)) {
              ESP_LOGI("clock", "Exiting clock mode");
              id(clock_mode_active) = false;
              
              // Restore normal brightness
              id(display).set_brightness(id(normal_brightness));
            }
            // Reset stopped timer
            id(stopped_time) = 0;
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

api:
  services:
    # Custom service to load playlist data (bypasses 255 char text limit)
    - service: load_playlists
      variables:
        playlist_json: string
      then:
        - lambda: |-
            ESP_LOGI("playlist", "Received playlist data via service");
            id(controller).load_playlist_data(playlist_json);
    
    # Custom service to load all favorites (radios + playlists)
    - service: load_all_favorites
      variables:
        favorites_json: string
      then:
        - lambda: |-
            ESP_LOGI("favorites", "Received all favorites data via service");
            id(controller).load_all_favorites(favorites_json);
    
    # Clear all saved presets from flash (restores YAML config)
    - service: clear_saved_presets
      then:
        - lambda: |-
            ESP_LOGI("presets", "Clearing all saved presets from flash");
            for (uint8_t i = 0; i < 8; i++) {
              id(controller).clear_preset_slot(i);
            }
            ESP_LOGI("presets", "Saved presets cleared - rebooting to restore YAML config");
            // Reboot to reload presets from YAML
            App.safe_reboot();

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Retro Radio Fallback"
  
  # Show connection status briefly, then auto-play last preset
  on_connect:
    - delay: 500ms
    - lambda: |-
        // Auto-play last preset if available
        if (!id(last_preset_name).empty()) {
          ESP_LOGI("boot", "Auto-playing last preset: %s", id(last_preset_name).c_str());
          id(controller).select_preset_by_name(id(last_preset_name));
        } else {
          ESP_LOGI("boot", "No last preset, showing stopped");
          id(stream_state).publish_state("stopped");
        }
  
  on_disconnect:
    - lambda: 'id(display).set_text("WIFI DISCONNECTED");'

# I2C bus configuration
i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: true
    frequency: 400kHz

# Time component (synced from Home Assistant)
time:
  - platform: homeassistant
    id: ha_time

# RetroText Display - 3 boards for 72x6 pixel display (18 characters)
retrotext_display:
  id: display
  brightness: 180  # Normal brightness (clock mode uses 60)
  boards:
    - 0x50  # Board 0 (left): ADDR=GND
    - 0x5F  # Board 1 (middle): ADDR=VCC  
    - 0x5A  # Board 2 (right): ADDR=SDA

# TCA8418 Keypad - Hardware matrix configuration
# AS5000E has 4 rows x 10 columns
tca8418_keypad:
  id: keypad
  address: 0x34
  rows: 4
  columns: 10

# Radio Controller - High-level preset management
# Note: Service calls disabled, using automation with text sensor instead
radio_controller:
  id: controller
  keypad_id: keypad
  display_id: display
  i2c_id: bus_a  # Auto-initialize panel LEDs at 0x55
  service: ""  # Disabled - using automation instead
  
  presets:
    - button: {row: 3, column: 3}
      display: "Radio 3FACH Luz"
      target: "Radio 3FACH"
    
    - button: {row: 3, column: 2}
      display: "WKCR Columbia U"
      target: "WKCR"
    
    - button: {row: 3, column: 1}
      display: "France Musique Hi-fi"
      target: "France Musique Hi-fi"
    
    - button: {row: 3, column: 0}
      display: "Radio Meuh FR"
      target: "Radio Meuh"
    
    - button: {row: 3, column: 8}
      display: "BBC NEWS"
      target: "radiobrowser://radio/98adecf7-2683-4408-9be7-02d3f9098eb8"
    
    - button: {row: 3, column: 7}
      display: "Radio LoRa"
      target: "Radio LoRa"
    
    - button: {row: 3, column: 6}
      display: "WTUL Tulane"
      target: "WTUL New Orleans"
    
    - button: {row: 3, column: 5}
      display: "BROWSE PLAYLISTS"
      target: "__PLAYLIST_MODE__"
  
  controls:
    encoder_button: {row: 2, column: 1}
    memory_button: {row: 2, column: 0}  # Hold 2sec to enter save preset mode

# Binary sensors (required for tca8418_keypad component to compile)
binary_sensor:
  # Minimal internal sensor to satisfy component dependencies
  # We use callbacks in radio_controller instead of binary sensors
  - platform: template
    name: "Keypad Active"
    id: keypad_active
    internal: true

# Text sensors
text_sensor:
  # Current preset name (display text)
  - platform: radio_controller
    radio_controller_id: controller
    name: "Current Preset"
    id: current_preset
    icon: mdi:radio
    on_value:
      then:
        # Store station name for use during loading
        - lambda: 'id(station_name).publish_state(x);'
        # Save as last preset for auto-play on boot
        - lambda: |-
            if (!x.empty() && x != "BROWSE PLAYLISTS") {
              id(last_preset_name) = x;
              ESP_LOGI("preset", "Saved last preset: %s", x.c_str());
            }
  
  # Current preset target (media_id for automation)
  - platform: template
    name: "Current Media ID"
    id: current_media_id
    icon: mdi:music-circle
  
  # Radio mode: "presets" or "playlists"
  - platform: template
    name: "Radio Mode"
    id: radio_mode
    icon: mdi:radio
  
  # Now playing from Home Assistant
  - platform: homeassistant
    id: now_playing
    entity_id: sensor.radio_now_playing_metadata
    on_value:
      then:
        # Sync preset LED when HA reports the current stream
        - lambda: |-
            ESP_LOGI("now_playing", "Received: %s", x.c_str());
            
            // NEW: Update radio controller with metadata
            id(controller).set_now_playing_metadata(x);
            
            // If we receive now_playing and stream_state is still loading, update it to playing
            // This fixes the spinner not clearing issue
            if (id(stream_state).state == "loading" && !x.empty()) {
              ESP_LOGI("now_playing", "Fixing stuck loading state - updating to playing");
              id(stream_state).publish_state("playing");
            }
            
            // Exit clock mode if we have valid media
            if (!id(current_media_id).state.empty()) {
              if (id(clock_mode_active)) {
                ESP_LOGI("clock", "Exiting clock mode due to active media");
                id(clock_mode_active) = false;
                id(display).set_brightness(id(normal_brightness));
              }
              
              // Sync LED using the stored media_id (always use this, not now_playing text)
              ESP_LOGI("now_playing", "Syncing LED with media_id: %s", id(current_media_id).state.c_str());
              id(controller).sync_preset_led_from_target(id(current_media_id).state);
            }
  
  # Store the target media player entity ID for volume control
  - platform: homeassistant
    name: "Volume Target Entity"
    id: ha_volume_target
    entity_id: input_select.radio_media_player_entity
    internal: true

# Select for preset selection
select:
  - platform: radio_controller
    radio_controller_id: controller
    name: "Radio Preset"
    icon: mdi:radio

# Text input for stream state (set by automation)
text:
  - platform: template
    name: "Stream State"
    id: stream_state
    optimistic: true
    initial_value: "ready"  # Changed from "stopped" to prevent clock flash on boot
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("stream_state", "Stream state changed to: %s", x.c_str());
            
            // Update radio controller with playback state
            if (x == "playing") {
              id(controller).set_playback_state(true);
            } else if (x == "stopped") {
              id(controller).set_playback_state(false);
              // Controller will handle display with stop icon
              
              // Reset stopped timer to start counting for clock mode
              id(stopped_time) = 0;
              
              // Clear media_id when stopped so clock mode can activate
              id(current_media_id).publish_state("");
            } else if (x == "ready") {
              // On boot with "ready" state, show stopped state properly
              id(controller).set_playback_state(false);
            }
            // "loading" state will show station name + spinner in interval
  
  - platform: template
    name: "Station Name"
    id: station_name
    optimistic: true
    initial_value: ""
    mode: text
    internal: true  # Hidden from HA UI
  
  # Station Name (internal, used for loading spinner)
  # Note: Playlist data is loaded via custom service below

# Sensors
sensor:
  # Volume potentiometer (GPIO33 / ADC1_CH5)
  - platform: adc
    pin: GPIO33
    name: "Volume Pot"
    id: volume_pot
    internal: true  # Don't expose to HA UI directly
    update_interval: 200ms
    attenuation: 12db  # 0-3.3V range
    filters:
      # Smooth out noise with a sliding window average
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2
      # Convert voltage (0-3.3V) to percentage (0-100)
      - calibrate_linear:
          - 0.0 -> 1.0
          - 3.3 -> 94.0
      # Apply deadzone to prevent oscillation
      - delta: 2.0  # Only send if changed by 2%
    on_value:
      then:
        - homeassistant.service:
            service: media_player.volume_set
            data:
              entity_id: !lambda |-
                return id(ha_volume_target).state;
              volume_level: !lambda |-
                // Convert 0-100 to 0.0-1.0
                return x / 100.0;
  
  # Volume readback from HA (for display sync)
  - platform: homeassistant
    name: "Speaker Volume"
    id: speaker_volume
    entity_id: sensor.radio_speaker_volume
    internal: true
    filters:
      # Convert 0.0-1.0 back to 0-100 percentage
      - multiply: 100

# Number sensors
number:
  # Display brightness control
  - platform: template
    name: "Display Brightness"
    id: display_brightness
    optimistic: true
    min_value: 10
    max_value: 255
    step: 5
    initial_value: 180
    mode: slider
    icon: mdi:brightness-6
    on_value:
      then:
        - lambda: |-
            // Update display brightness
            id(display).set_brightness((uint8_t)x);
            // Store as normal brightness (for restoring after clock mode)
            id(normal_brightness) = (uint8_t)x;
            ESP_LOGI("brightness", "Display brightness set to: %d", (int)x);
  
