external_components:
  - source:
      type: local
      path: ../components

esphome:
  name: retro-radio
  friendly_name: Retro Radio
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(controller).set_preset_target_sensor(id(current_media_id));
          id(controller).set_radio_mode_sensor(id(radio_mode));
          id(radio_mode).publish_state("presets");

# Global variables for clock mode and state
globals:
  - id: stopped_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: clock_mode_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: normal_brightness
    type: uint8_t
    restore_value: no
    initial_value: '180'
  - id: last_preset_name
    type: std::string
    restore_value: yes
    initial_value: '""'

# Intervals for clock mode
interval:
  # Clock mode checker and updater
  - interval: 1s
    then:
      - lambda: |-
          // Enter clock mode when stopped (not playing and not browsing)
          bool is_playing = id(controller).is_playing();
          bool user_browsing = id(controller).is_browse_mode_active();
          bool truly_stopped = !is_playing && !user_browsing;
          
          // Reset clock timer if user is browsing or playing
          if ((user_browsing || is_playing) && id(clock_mode_active)) {
            ESP_LOGI("clock", "Exiting clock mode due to %s", is_playing ? "playback" : "user browsing");
            id(clock_mode_active) = false;
            id(display).set_brightness(id(normal_brightness));
            id(stopped_time) = 0;  // Reset timer
          }
          
          if (truly_stopped) {
            // Initialize stopped_time if this is the first check
            if (id(stopped_time) == 0) {
              id(stopped_time) = millis();
              ESP_LOGD("clock", "Started stopped timer (stream:%s, media:%s)", 
                       id(stream_state).state.c_str(), 
                       id(current_media_id).state.c_str());
            }
            
            // Enter clock mode after 10 seconds of being stopped
            unsigned long stopped_duration = (millis() - id(stopped_time)) / 1000;
            if (stopped_duration >= 10 && !id(clock_mode_active)) {
              ESP_LOGI("clock", "Entering clock mode after %lu seconds", stopped_duration);
              id(clock_mode_active) = true;
              
              // Use moderate brightness for clock (brighter than before)
              id(display).set_brightness(100);
            }
            
            // Update clock display if in clock mode
            // Format: "Oct  5 Su 19:15:46" (date at lower brightness, time at higher)
            if (id(clock_mode_active)) {
              auto time = id(ha_time).now();
              if (time.is_valid()) {
                char time_str[20];
                const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
                const char* days[] = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"};
                
                // Format: "Oct  5 Su 19:15:46" (18 chars)
                // First 10 chars are date (dimmer), last 8 are time (brighter)
                snprintf(time_str, sizeof(time_str), "%s %2d %s %02d:%02d:%02d",
                         months[time.month - 1],
                         time.day_of_month,
                         days[time.day_of_week - 1],
                         time.hour,
                         time.minute,
                         time.second);
                
                // Render with date dimmer (60) and time brighter (180)
                id(display).set_text_with_brightness(time_str, 60, 180, 10);
              }
            }
          } else {
            // Exit clock mode if streaming, loading, or media is active
            if (id(clock_mode_active)) {
              ESP_LOGI("clock", "Exiting clock mode");
              id(clock_mode_active) = false;
              
              // Restore normal brightness
              id(display).set_brightness(id(normal_brightness));
            }
            // Reset stopped timer
            id(stopped_time) = 0;
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

api:
  # Request favorites sync after API connection established
  on_client_connected:
    - delay: 2s  # Wait for HA event system to be fully ready
    - homeassistant.event:
        event: esphome.retro_radio_sync_favorites
    - lambda: |-
        ESP_LOGI("boot", "Requested favorites sync from Home Assistant");
  
  services:
    # Custom service to load playlist data (bypasses 255 char text limit)
    - service: load_playlists
      variables:
        playlist_json: string
      then:
        - lambda: |-
            ESP_LOGI("playlist", "Received playlist data via service");
            id(controller).load_playlist_data(playlist_json);
    
    # Custom service to load all favorites (radios + playlists)
    - service: load_all_favorites
      variables:
        favorites_json: string
      then:
        - lambda: |-
            ESP_LOGI("favorites", "Received all favorites data via service");
            id(controller).load_all_favorites(favorites_json);
    
    # Clear all saved presets from flash (restores YAML config)
    - service: clear_saved_presets
      then:
        - lambda: |-
            ESP_LOGI("presets", "Clearing all saved presets from flash");
            for (uint8_t i = 0; i < 7; i++) {
              id(controller).clear_preset_slot(i);
            }
            ESP_LOGI("presets", "Saved presets cleared - rebooting to restore YAML config");
            // Reboot to reload presets from YAML
            App.safe_reboot();
    
    # Start VU meter test (sweeps voltage across meters for 10 seconds)
    - service: start_vu_meter_test
      then:
        - lambda: |-
            ESP_LOGI("vu_meter", "Starting VU meter test");
            id(controller).start_vu_meter_test();

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Retro Radio Fallback"
  
  # Show connection status briefly, then auto-play last preset
  on_connect:
    - delay: 500ms
    - lambda: |-
        ESP_LOGI("boot", "WiFi connected, preparing to sync favorites");
        
        // Disable shimmer effect now that we're connected
        id(display).set_shimmer_mode(false);
        
        // Auto-play last preset if available
        if (!id(last_preset_name).empty()) {
          ESP_LOGI("boot", "Auto-playing last preset: %s", id(last_preset_name).c_str());
          id(controller).select_preset_by_name(id(last_preset_name));
        } else {
          ESP_LOGI("boot", "No last preset, showing stopped");
          id(stream_state).publish_state("stopped");
        }
  
  on_disconnect:
    - lambda: 'id(display).set_text("WIFI DISCONNECTED");'

# I2C bus configuration
i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: true
    frequency: 400kHz

# Time component (synced from Home Assistant)
time:
  - platform: homeassistant
    id: ha_time

# RetroText Display - 3 boards for 72x6 pixel display (18 characters)
retrotext_display:
  id: display
  brightness: 180  # Normal brightness (clock mode uses 60)
  boards:
    - 0x50  # Board 0 (left): ADDR=GND
    - 0x5F  # Board 1 (middle): ADDR=VCC  
    - 0x5A  # Board 2 (right): ADDR=SDA

# TCA8418 Keypad - Hardware matrix configuration
# AS5000E has 4 rows x 10 columns
tca8418_keypad:
  id: keypad
  address: 0x34
  rows: 4
  columns: 10

# Radio Controller - High-level preset management
# Note: Service calls disabled, using automation with text sensor instead
radio_controller:
  id: controller
  keypad_id: keypad
  display_id: display
  i2c_id: bus_a  # Auto-initialize panel LEDs at 0x55
  service: ""  # Disabled - using automation instead
  mode_text_sensor: mode_selector
  
  presets:
    - button: {row: 3, column: 3}
      display: "Radio 3FACH Luz"
      target: "Radio 3FACH"
    
    - button: {row: 3, column: 2}
      display: "WKCR Columbia U"
      target: "WKCR"
    
    - button: {row: 3, column: 1}
      display: "France Musique Hi-fi"
      target: "radiobrowser://radio/5e992e1e-e6ef-11e9-a96c-52543be04c81"
    
    - button: {row: 3, column: 0}
      display: "Radio Meuh FR"
      target: "Radio Meuh"
    
    - button: {row: 3, column: 8}
      display: "BBC NEWS"
      target: "radiobrowser://radio/98adecf7-2683-4408-9be7-02d3f9098eb8"
    
    - button: {row: 3, column: 7}
      display: "Radio LoRa"
      target: "Radio LoRa"
    
    - button: {row: 3, column: 6}
      display: "WTUL Tulane"
      target: "WTUL"
  
  controls:
    encoder_button: {row: 2, column: 1}
    memory_button: {row: 3, column: 5}  # Tap to enter save mode, tap again to cancel

# Binary sensors (required for tca8418_keypad component to compile)
binary_sensor:
  # Minimal internal sensor to satisfy component dependencies
  # We use callbacks in radio_controller instead of binary sensors
  - platform: template
    name: "Keypad Active"
    id: keypad_active
    internal: true

# Text sensors
text_sensor:
  # Current preset name (display text)
  - platform: radio_controller
    radio_controller_id: controller
    name: "Current Preset"
    id: current_preset
    icon: mdi:radio
    on_value:
      then:
        # Save as last preset for auto-play on boot
        - lambda: |-
            if (!x.empty() && x != "BROWSE PLAYLISTS") {
              id(last_preset_name) = x;
              ESP_LOGI("preset", "Saved last preset: %s", x.c_str());
            }
  
  # Current preset target (media_id for automation)
  - platform: template
    name: "Current Media ID"
    id: current_media_id
    icon: mdi:music-circle
  
  # Radio mode: "presets" or "playlists"
  - platform: template
    name: "Radio Mode"
    id: radio_mode
    icon: mdi:radio
  
  # Mode selector: "Stereo", "Stereo-Far", "Q", "Mono"
  - platform: template
    name: "Mode Selector"
    id: mode_selector
    icon: mdi:radio-tower
  
  # Now playing from Home Assistant
  - platform: homeassistant
    id: now_playing
    entity_id: sensor.radio_now_playing_metadata
    on_value:
      then:
        # Sync preset LED when HA reports the current stream
        - lambda: |-
            ESP_LOGI("now_playing", "Received: %s", x.c_str());
            
            // NEW: Update radio controller with metadata
            id(controller).set_now_playing_metadata(x);
            
            // If we receive now_playing and stream_state is still loading, update it to playing
            if (id(stream_state).state == "loading" && !x.empty()) {
              ESP_LOGI("now_playing", "Stream loaded - updating to playing");
              id(stream_state).publish_state("playing");
            }
            
            // Exit clock mode if we have valid media or playing from HA
            bool has_media = !id(current_media_id).state.empty();
            bool is_playing_from_ha = (x != "Ready" && x != "Stopped" && x != "ready" && 
                                      x != "stopped" && !x.empty());
            
            if (has_media || is_playing_from_ha) {
              if (id(clock_mode_active)) {
                ESP_LOGI("clock", "Exiting clock mode due to active media");
                id(clock_mode_active) = false;
                id(display).set_brightness(id(normal_brightness));
              }
              
              // Try to sync LED using media_id first (from device-initiated playback)
              if (has_media) {
                ESP_LOGI("now_playing", "Syncing LED with media_id: %s", id(current_media_id).state.c_str());
                id(controller).sync_preset_led_from_target(id(current_media_id).state);
              } else {
                // Fallback: sync by station name (from HA-initiated playback)
                ESP_LOGI("now_playing", "Syncing LED with station name: %s", x.c_str());
                id(controller).sync_preset_led_from_name(x);
              }
            }
  
  # Store the target media player entity ID for volume control
  - platform: homeassistant
    name: "Volume Target Entity"
    id: ha_volume_target
    entity_id: input_select.radio_media_player_entity
    internal: true

# Select for preset selection
select:
  - platform: radio_controller
    radio_controller_id: controller
    name: "Radio Preset"
    icon: mdi:radio

# Text input for stream state (set by automation)
text:
  - platform: template
    name: "Stream State"
    id: stream_state
    optimistic: true
    initial_value: "ready"  # Changed from "stopped" to prevent clock flash on boot
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("stream_state", "Stream state changed to: %s", x.c_str());
            
            // Update radio controller with playback state
            if (x == "playing") {
              id(controller).set_playback_state(true);
              // Disable shimmer when playing starts
              id(display).set_shimmer_mode(false);
            } else if (x == "loading") {
              // Enable shimmer effect during loading
              id(display).set_shimmer_mode(true);
            } else if (x == "stopped") {
              id(controller).set_playback_state(false);
              // Controller will handle display with stop icon
              
              // Disable shimmer when stopped
              id(display).set_shimmer_mode(false);
              
              // Reset stopped timer to start counting for clock mode
              id(stopped_time) = 0;
              
              // Clear media_id when stopped so clock mode can activate
              id(current_media_id).publish_state("");
            } else if (x == "ready") {
              // On boot with "ready" state, show stopped state properly
              id(controller).set_playback_state(false);
              id(display).set_shimmer_mode(false);
            }

# Sensors
sensor:
  # Volume potentiometer (GPIO33 / ADC1_CH5)
  - platform: adc
    pin: GPIO33
    name: "Volume Pot"
    id: volume_pot
    internal: true  # Don't expose to HA UI directly
    update_interval: 200ms
    attenuation: 12db  # 0-3.3V range
    filters:
      # Smooth out noise with a sliding window average
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2
      # Convert voltage (0-3.3V) to percentage (0-100)
      - calibrate_linear:
          - 0.0 -> 1.0
          - 3.3 -> 94.0
      # Apply deadzone to prevent oscillation
      - delta: 2.0  # Only send if changed by 2%
    on_value:
      then:
        - homeassistant.service:
            service: media_player.volume_set
            data:
              entity_id: !lambda |-
                return id(ha_volume_target).state;
              volume_level: !lambda |-
                // Convert 0-100 to 0.0-1.0
                return x / 100.0;
  
  # Volume readback from HA (for display sync)
  - platform: homeassistant
    name: "Speaker Volume"
    id: speaker_volume
    entity_id: sensor.radio_speaker_volume
    internal: true
    filters:
      # Convert 0.0-1.0 back to 0-100 percentage
      - multiply: 100

# Number sensors
number:
  # Display brightness control
  - platform: template
    name: "Display Brightness"
    id: display_brightness
    optimistic: true
    min_value: 10
    max_value: 255
    step: 5
    initial_value: 180
    mode: slider
    icon: mdi:brightness-6
    on_value:
      then:
        - lambda: |-
            // Update display brightness
            id(display).set_brightness((uint8_t)x);
            // Store as normal brightness (for restoring after clock mode)
            id(normal_brightness) = (uint8_t)x;
            ESP_LOGI("brightness", "Display brightness set to: %d", (int)x);
  
